<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Chess Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"
            integrity="sha512-xRllwz2gdZciIB+AkEbeq+gVhX8VB8XsfqeFbUh+SzHlN96dEduwtTuVuc2u9EROlmW9+yhRlxjif66ORpsgVA=="
            crossOrigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="module">

    import { Chess } from 'https://unpkg.com/chess.js@0.13.4/chess.js';

    tailwind.config = {
    theme: {
    extend: {
    colors: {
    'glass': 'rgba(255, 255, 255, 0.1)',
                        'glass-dark': 'rgba(0, 0, 0, 0.1)',
                        'board-light': '#f0d9b5',
                        'board-dark': '#b58863'
                    },
                    backdropBlur: {
                        'xs': '2px',
                    }
                }
            }
        }
    </script>
    <style>
        .chess-piece {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
            width: 80%;
            height: 80%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        .chess-square {
            transition: all 0.2s ease;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .selected {
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, rgba(59, 130, 246, 0.1) 70%);
            box-shadow: inset 0 0 20px rgba(59, 130, 246, 0.3);
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            z-index: 10;
        }
        
        .king-in-check {
            background: radial-gradient(circle, rgba(239, 68, 68, 0.3) 0%, rgba(239, 68, 68, 0.1) 70%);
            box-shadow: inset 0 0 20px rgba(239, 68, 68, 0.3);
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .glass-effect-dark {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Disable right-click context menu on chess board */
        .grid {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        /* Disabled button styling */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        button:disabled:hover {
            transform: none !important;
        }

        /* Board annotations */
        .board-annotations {
            position: relative;
            display: inline-block;
        }

        .file-labels {
            position: absolute;
            bottom: -30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            font-size: 14px;
            font-weight: 600;
            color: #e5e7eb;
        }

        .rank-labels {
            position: absolute;
            top: 0;
            left: -30px;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            font-size: 14px;
            font-weight: 600;
            color: #e5e7eb;
        }

        .file-label, .rank-label {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Board flipping */
        .board-flipped {
            transform: rotate(180deg);
        }

        .board-flipped .chess-square {
            transform: rotate(180deg);
        }

        .board-flipped .file-labels {
            transform: rotate(180deg);
        }

        .board-flipped .rank-labels {
            transform: rotate(180deg);
        }

        /* Chess.com Individual Piece URLs */
        .piece-white-king { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wk.png'); }
        .piece-white-queen { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wq.png'); }
        .piece-white-rook { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wr.png'); }
        .piece-white-bishop { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wb.png'); }
        .piece-white-knight { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wn.png'); }
        .piece-white-pawn { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wp.png'); }
        
        .piece-black-king { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bk.png'); }
        .piece-black-queen { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bq.png'); }
        .piece-black-rook { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/br.png'); }
        .piece-black-bishop { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bb.png'); }
        .piece-black-knight { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bn.png'); }
        .piece-black-pawn { background-image: url('https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bp.png'); }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center p-4">
    <div class="fade-in w-full max-w-6xl">
        <!-- Game Container -->
        <div class="flex flex-col lg:flex-row gap-6 items-center lg:items-start">
            <!-- Chess Board -->
            <div class="glass-effect rounded-2xl p-6">
                <div class="board-annotations">
                    <div class="rank-labels">
                        <div class="rank-label">8</div>
                        <div class="rank-label">7</div>
                        <div class="rank-label">6</div>
                        <div class="rank-label">5</div>
                        <div class="rank-label">4</div>
                        <div class="rank-label">3</div>
                        <div class="rank-label">2</div>
                        <div class="rank-label">1</div>
                    </div>
                    <div class="grid grid-cols-8 w-96 h-96 lg:w-[34rem] lg:h-[34rem] xl:w-[38rem] xl:h-[38rem] 2xl:w-[42rem] 2xl:h-[42rem] rounded-xl overflow-hidden shadow-2xl">
                        <!-- Chess squares will be generated here -->
                    </div>
                    <div class="file-labels">
                        <div class="file-label">a</div>
                        <div class="file-label">b</div>
                        <div class="file-label">c</div>
                        <div class="file-label">d</div>
                        <div class="file-label">e</div>
                        <div class="file-label">f</div>
                        <div class="file-label">g</div>
                        <div class="file-label">h</div>
                    </div>
                </div>
            </div>

            <!-- Game Info Panel -->
            <div class="glass-effect rounded-2xl p-6 w-full lg:w-80">
                <div class="space-y-4">
                    <div class="text-center">
                        <h3 class="text-xl font-semibold text-white mb-2">Game Status</h3>
                        <div id="gameStatus" class="text-green-400 font-medium">White's Turn</div>
                    </div>
                    
                    <div class="pt-4 border-t border-gray-600">
                        <div class="space-y-2">
                            <h4 class="text-sm font-medium text-gray-300">Game Info</h4>
                            <div id="checkInfo" class="text-xs text-gray-400 hidden">
                                <div class="flex items-center space-x-2">
                                    <div class="w-2 h-2 bg-red-400 rounded-full"></div>
                                    <span>King in Check</span>
                                </div>
                            </div>
                            <div id="moveInfo" class="text-xs text-gray-400">
                                <span>Last Move: </span><span id="lastMove">-</span>
                            </div>
                        </div>
                    </div>

                    <div class="pt-4 border-t border-gray-600">
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-2">Game Mode</label>
                                <select id="gameMode" class="w-full bg-gray-800 text-white rounded-lg px-3 py-2 border border-gray-600 focus:border-blue-500 focus:outline-none">
                                    <option value="human">Human vs Human</option>
                                    <option value="bot" selected>Human vs Bot</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-300 mb-2">Your Color</label>
                                <select id="playerColor" class="w-full bg-gray-800 text-white rounded-lg px-3 py-2 border border-gray-600 focus:border-blue-500 focus:outline-none">
                                    <option value="random" selected>Random</option>
                                    <option value="white">White</option>
                                    <option value="black">Black</option>
                                </select>
                            </div>
                            <div id="botControls" class="hidden">
                                <label class="block text-sm font-medium text-gray-300 mb-2">Bot Difficulty</label>
                                <select id="botDifficulty" class="w-full bg-gray-800 text-white rounded-lg px-3 py-2 border border-gray-600 focus:border-blue-500 focus:outline-none">
                                    <option value="1">Easy</option>
                                    <option value="3">Medium</option>
                                    <option value="5">Hard</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="pt-4 border-t border-gray-600">
                        <div class="space-y-3">
                            <div class="grid grid-cols-2 gap-3">
                                <button id="surrenderBtn" class="bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-medium py-3 px-4 rounded-xl transition-all duration-300 transform hover:scale-105 shadow-lg">
                                    Surrender
                                </button>
                                <button id="restartBtn" class="bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-medium py-3 px-4 rounded-xl transition-all duration-300 transform hover:scale-105 shadow-lg">
                                    Restart
                                </button>
                            </div>
                            <button id="drawBtn" class="w-full bg-gradient-to-r from-yellow-500 to-orange-600 hover:from-yellow-600 hover:to-orange-700 text-white font-medium py-3 px-4 rounded-xl transition-all duration-300 transform hover:scale-105 shadow-lg hidden">
                                Offer Draw
                            </button>
                        </div>
                    </div>
                    
                    <div class="text-xs text-gray-400 text-center">
                        <p>Click on pieces to move them</p>
                        <p>Valid moves will be highlighted</p>
                        <p id="botInfo" class="hidden mt-2">Playing against AI bot</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pawn Promotion Modal -->
    <div id="promotionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="glass-effect rounded-2xl p-6 max-w-sm w-full mx-4">
            <h3 class="text-xl font-semibold text-white mb-4 text-center">Choose Promotion</h3>
            <div class="grid grid-cols-4 gap-3">
                <button class="promotion-piece bg-white rounded-lg p-3 hover:bg-gray-100 transition-colors" data-piece="q">
                    <div class="piece-white-queen w-full h-12 bg-contain bg-center bg-no-repeat"></div>
                </button>
                <button class="promotion-piece bg-white rounded-lg p-3 hover:bg-gray-100 transition-colors" data-piece="r">
                    <div class="piece-white-rook w-full h-12 bg-contain bg-center bg-no-repeat"></div>
                </button>
                <button class="promotion-piece bg-white rounded-lg p-3 hover:bg-gray-100 transition-colors" data-piece="b">
                    <div class="piece-white-bishop w-full h-12 bg-contain bg-center bg-no-repeat"></div>
                </button>
                <button class="promotion-piece bg-white rounded-lg p-3 hover:bg-gray-100 transition-colors" data-piece="n">
                    <div class="piece-white-knight w-full h-12 bg-contain bg-center bg-no-repeat"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- PGN Modal -->
    <div id="pgnModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="glass-effect rounded-2xl p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
            <h3 class="text-xl font-semibold text-white mb-4 text-center">Game PGN</h3>
            <div class="bg-gray-800 rounded-lg p-4 mb-4">
                <pre id="pgnText" class="text-green-400 text-sm whitespace-pre-wrap font-mono"></pre>
            </div>
            <div class="flex justify-center space-x-3">
                <button id="copyPgnBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg transition-colors">
                    Copy PGN
                </button>
                <button id="closePgnBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded-lg transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { Chess } from 'https://unpkg.com/chess.js@0.13.4/chess.js';
        
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'glass': 'rgba(255, 255, 255, 0.1)',
                        'glass-dark': 'rgba(0, 0, 0, 0.1)',
                        'board-light': '#f0d9b5',
                        'board-dark': '#b58863'
                    },
                    backdropBlur: {
                        'xs': '2px',
                    }
                }
            }
        }

        // Chess game implementation with chess.js
        class ChessGame {
            constructor() {
                this.chess = new Chess();
                this.selectedPiece = null;
                this.gameMode = 'bot';
                this.botDifficulty = 3;
                this.playerColor = 'random';
                this.gameStatus = document.getElementById('gameStatus');
                this.surrenderBtn = document.getElementById('surrenderBtn');
                this.restartBtn = document.getElementById('restartBtn');
                this.drawBtn = document.getElementById('drawBtn');
                this.gameModeSelect = document.getElementById('gameMode');
                this.botDifficultySelect = document.getElementById('botDifficulty');
                this.playerColorSelect = document.getElementById('playerColor');
                this.botControls = document.getElementById('botControls');
                this.botInfo = document.getElementById('botInfo');
                this.promotionModal = document.getElementById('promotionModal');
                this.pendingPromotion = null;
                this.pgnModal = document.getElementById('pgnModal');
                this.pgnText = document.getElementById('pgnText');
                this.copyPgnBtn = document.getElementById('copyPgnBtn');
                this.closePgnBtn = document.getElementById('closePgnBtn');
                
                this.loadGameState();
                this.setupEventListeners();
                this.renderBoard();
                this.updateGameStatus();
                this.syncUIWithGameState();
                
                // Only initialize if no game was loaded (fresh start)
                if (!localStorage.getItem('chessGameState')) {
                    this.initializeGame();
                }
            }

            initializeGame() {
                // Ensure player color is determined if random and not already determined
                if (this.playerColor === 'random' && !this._determinedColor) {
                    this._determinedColor = Math.random() < 0.5 ? 'w' : 'b';
                    console.log('Player color determined:', this._determinedColor === 'w' ? 'White' : 'Black');
                    this.saveGameState(); // Save the determined color immediately
                }
                
                // For fresh games: if playing against bot and player is black, bot should move first
                if (this.gameMode === 'bot' && this.getPlayerColor() === 'b') {
                    console.log('Fresh game: Player is black, bot moves first');
                    setTimeout(() => this.makeBotMove(), 500);
                } else {
                    console.log('Fresh game: Player is white or not bot mode');
                }
            }

            saveGameState() {
                const gameState = {
                    fen: this.chess.fen(),
                    gameMode: this.gameMode,
                    botDifficulty: this.botDifficulty,
                    playerColor: this.playerColor,
                    determinedColor: this._determinedColor,
                    timestamp: Date.now()
                };
                localStorage.setItem('chessGameState', JSON.stringify(gameState));
            }

            loadGameState() {
                const savedState = localStorage.getItem('chessGameState');
                if (savedState) {
                    try {
                        const gameState = JSON.parse(savedState);
                        
                        // Load game position
                        if (gameState.fen) {
                            this.chess = new Chess(gameState.fen);
                        }
                        
                        // Load game mode
                        if (gameState.gameMode) {
                            this.gameMode = gameState.gameMode;
                            // Update UI elements
                            this.gameModeSelect.value = this.gameMode;
                            this.botControls.classList.toggle('hidden', this.gameMode !== 'bot');
                            this.botInfo.classList.toggle('hidden', this.gameMode !== 'bot');
                        }
                        
                        // Load bot difficulty
                        if (gameState.botDifficulty) {
                            this.botDifficulty = gameState.botDifficulty;
                            this.botDifficultySelect.value = this.botDifficulty;
                        }
                        
                        // Load player color
                        if (gameState.playerColor) {
                            this.playerColor = gameState.playerColor;
                            // Update UI elements
                            document.getElementById('playerColor').value = this.playerColor;
                        }
                        
                        // Load determined color
                        if (gameState.determinedColor) {
                            this._determinedColor = gameState.determinedColor;
                        }
                    } catch (error) {
                        localStorage.removeItem('chessGameState');
                    }
                }
                
                // After loading game state, check if bot should move
                if (this.gameMode === 'bot' && !this.isPlayerTurn() && !this.chess.game_over()) {
                    setTimeout(() => this.makeBotMove(), 500);
                }
            }

            syncUIWithGameState() {
                // Ensure UI reflects current game state
                this.gameModeSelect.value = this.gameMode;
                this.botDifficultySelect.value = this.botDifficulty;
                this.playerColorSelect.value = this.playerColor;
                this.botControls.classList.toggle('hidden', this.gameMode !== 'bot');
                this.botInfo.classList.toggle('hidden', this.gameMode !== 'bot');
                // Show draw button when playing against bot, but disable it if game hasn't started or is over
                this.drawBtn.classList.toggle('hidden', this.gameMode !== 'bot');
                
                const shouldDisable = this.gameMode !== 'bot' || this.chess.game_over() || this.chess.history().length === 0;
                this.drawBtn.disabled = shouldDisable;
                
                // Handle surrender and restart button states
                const gameInProgress = !this.chess.game_over() && this.chess.history().length > 0;
                this.surrenderBtn.disabled = !gameInProgress;
                this.restartBtn.disabled = gameInProgress;
                
                // Re-render board to update flipping
                this.renderBoard();
            }

            getPieceSymbol(piece) {
                // Map chess.js piece types to CSS class names
                const typeMap = {
                    'p': 'pawn',
                    'n': 'knight', 
                    'b': 'bishop',
                    'r': 'rook',
                    'q': 'queen',
                    'k': 'king'
                };
                
                // Map chess.js color codes to full color names
                const colorMap = {
                    'w': 'white',
                    'b': 'black'
                };
                
                const pieceType = typeMap[piece.type] || piece.type;
                const pieceColor = colorMap[piece.color] || piece.color;
                return `piece-${pieceColor}-${pieceType}`;
            }

            findKingPosition(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = String.fromCharCode(97 + col) + (8 - row);
                        const piece = this.chess.get(square);
                        if (piece && piece.type === 'k' && piece.color === color) {
                            return square;
                        }
                    }
                }
                return null;
            }

            highlightKingInCheck() {
                // Remove previous check highlights
                document.querySelectorAll('.chess-square').forEach(sq => {
                    sq.classList.remove('king-in-check');
                });

                // Check if current player's king is in check
                if (this.chess.in_check()) {
                    const currentColor = this.chess.turn();
                    const kingSquare = this.findKingPosition(currentColor);
                    if (kingSquare) {
                        const kingElement = document.querySelector(`[data-square="${kingSquare}"]`);
                        if (kingElement) {
                            kingElement.classList.add('king-in-check');
                        }
                    }
                }
            }

            renderBoard() {
                const boardContainer = document.querySelector('.grid');
                const boardAnnotations = document.querySelector('.board-annotations');
                boardContainer.innerHTML = '';

                // Apply board flipping
                if (this.shouldFlipBoard()) {
                    boardAnnotations.classList.add('board-flipped');
                } else {
                    boardAnnotations.classList.remove('board-flipped');
                }

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const isLight = (row + col) % 2 === 0;
                        const squareName = String.fromCharCode(97 + col) + (8 - row);
                        
                        square.className = `chess-square w-full h-full flex items-center justify-center cursor-pointer aspect-square ${
                            isLight ? 'bg-board-light' : 'bg-board-dark'
                        }`;
                        
                        square.dataset.square = squareName;

                        const piece = this.chess.get(squareName);
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            const pieceClass = this.getPieceSymbol(piece);
                            pieceElement.className = `chess-piece ${pieceClass}`;
                            square.appendChild(pieceElement);
                        }

                        boardContainer.appendChild(square);
                    }
                }
                
                // Highlight king in check after board is rendered
                this.highlightKingInCheck();
            }

            getValidMoves(square) {
                return this.chess.moves({ square: square, verbose: true });
            }

            makeMove(fromSquare, toSquare, promotion = null) {
                const move = {
                    from: fromSquare,
                    to: toSquare,
                    promotion: promotion
                };

                const result = this.chess.move(move);
                
                if (result) {
                    // console.log('Move successful, playing sound...');
                    this.playMoveSound();
                    this.renderBoard();
                    this.updateGameStatus();
                    this.saveGameState();
                    this.syncUIWithGameState();
                    
                    // Bot's turn
                    if (this.gameMode === 'bot' && !this.isPlayerTurn()) {
                        setTimeout(() => this.makeBotMove(), 500);
                    }
                }
                
                return result;
            }

            handlePawnPromotion(fromSquare, toSquare) {
                const piece = this.chess.get(fromSquare);
                if (piece && piece.type === 'p') {
                    const targetRank = toSquare.charAt(1);
                    const isPromotion = (piece.color === 'w' && targetRank === '8') || 
                                       (piece.color === 'b' && targetRank === '1');
                    
                    // console.log('Pawn promotion check:', {
                    //     piece: piece,
                    //     targetRank: targetRank,
                    //     isPromotion: isPromotion,
                    //     fromSquare: fromSquare,
                    //     toSquare: toSquare
                    // });
                    
                    if (isPromotion) {
                        this.pendingPromotion = { from: fromSquare, to: toSquare };
                        this.showPromotionModal(piece.color);
                        return true;
                    }
                }
                return false;
            }

            showPromotionModal(color) {
                const modal = this.promotionModal;
                const pieces = modal.querySelectorAll('.promotion-piece div');
                
                // Update piece colors based on the promoting player
                pieces.forEach((piece, index) => {
                    const pieceTypes = ['queen', 'rook', 'bishop', 'knight'];
                    piece.className = `piece-${color === 'w' ? 'white' : 'black'}-${pieceTypes[index]} w-full h-12 bg-contain bg-center bg-no-repeat`;
                });
                
                modal.classList.remove('hidden');
            }

            hidePromotionModal() {
                this.promotionModal.classList.add('hidden');
                this.pendingPromotion = null;
            }

            getPlayerColor() {
                if (this.playerColor === 'random') {
                    // If we haven't determined the random color yet, set it
                    if (!this._determinedColor) {
                        this._determinedColor = Math.random() < 0.5 ? 'w' : 'b';
                    }
                    return this._determinedColor;
                }
                return this.playerColor === 'white' ? 'w' : 'b';
            }

            isPlayerTurn() {
                const currentTurn = this.chess.turn();
                const playerColor = this.getPlayerColor();
                const isPlayerTurn = currentTurn === playerColor;
                
                // Debug logging
                console.log('Turn check:', {
                    currentTurn: currentTurn,
                    playerColor: playerColor,
                    isPlayerTurn: isPlayerTurn,
                    gameMode: this.gameMode,
                    determinedColor: this._determinedColor
                });
                
                return isPlayerTurn;
            }

            shouldFlipBoard() {
                return this.getPlayerColor() === 'b';
            }

            makeBotMove() {
                if (this.chess.game_over()) return;

                const moves = this.chess.moves();
                if (moves.length === 0) return;

                // Simple bot: random move with some basic evaluation
                let bestMove = null;
                let bestScore = -Infinity;

                for (let i = 0; i < Math.min(moves.length, this.botDifficulty * 10); i++) {
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    this.chess.move(move);
                    
                    const score = this.evaluatePosition();
                    
                    this.chess.undo();
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }

                if (bestMove) {
                    this.chess.move(bestMove);
                    // console.log('Bot move successful, playing sound...');
                    this.playMoveSound();
                    this.renderBoard();
                    this.updateGameStatus();
                    this.saveGameState();
                    this.syncUIWithGameState();
                }
            }

            evaluatePosition() {
                let score = 0;
                const pieceValues = {
                    'p': 1,   // pawn
                    'n': 3,   // knight
                    'b': 3,   // bishop
                    'r': 5,   // rook
                    'q': 9,   // queen
                    'k': 0    // king (not counted in material)
                };

                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const square = String.fromCharCode(97 + j) + (8 - i);
                        const piece = this.chess.get(square);
                        
                        if (piece) {
                            const value = pieceValues[piece.type] || 0;
                            score += piece.color === 'b' ? value : -value;
                        }
                    }
                }

                return score;
            }

            updateGameStatus() {
                const checkInfo = document.getElementById('checkInfo');
                const lastMove = document.getElementById('lastMove');
                
                console.log('updateGameStatus called');
                console.log('Game over:', this.chess.game_over());
                console.log('In checkmate:', this.chess.in_checkmate());
                console.log('In draw:', this.chess.in_draw());
                console.log('In stalemate:', this.chess.in_stalemate());
                
                if (this.chess.in_checkmate()) {
                    console.log('Checkmate detected');
                    this.gameStatus.textContent = `Checkmate! ${this.chess.turn() === 'w' ? 'Black' : 'White'} wins!`;
                    this.gameStatus.className = 'text-red-400 font-medium';
                    checkInfo.classList.add('hidden');
                    this.syncUIWithGameState(); // Update draw button state
                    // Call handleGameOver to show PGN modal
                    setTimeout(() => this.handleGameOver(), 100);
                } else if (this.chess.in_draw()) {
                    console.log('Draw detected');
                    this.gameStatus.textContent = 'Draw!';
                    this.gameStatus.className = 'text-yellow-400 font-medium';
                    checkInfo.classList.add('hidden');
                    this.syncUIWithGameState(); // Update draw button state
                    // Call handleGameOver to show PGN modal
                    setTimeout(() => this.handleGameOver(), 100);
                } else if (this.chess.in_check()) {
                    this.gameStatus.textContent = `${this.chess.turn() === 'w' ? 'White' : 'Black'}'s Turn (Check!)`;
                    this.gameStatus.className = 'text-orange-400 font-medium';
                    checkInfo.classList.remove('hidden');
                } else {
                    this.gameStatus.textContent = `${this.chess.turn() === 'w' ? 'White' : 'Black'}'s Turn`;
                    this.gameStatus.className = this.chess.turn() === 'w' ? 'text-white font-medium' : 'text-gray-800 font-medium';
                    checkInfo.classList.add('hidden');
                }
                
                // Update last move
                const history = this.chess.history();
                if (history.length > 0) {
                    lastMove.textContent = history[history.length - 1];
                } else {
                    lastMove.textContent = '-';
                }
            }

            handleGameOver() {
                console.log('handleGameOver called');
                // Only show PGN modal if there are moves in the game
                if (this.chess.history().length > 0) {
                    setTimeout(() => {
                        console.log('Showing PGN modal');
                        this.showPGNModal();
                    }, 1000);
                } else {
                    console.log('No moves made, skipping PGN modal');
                }
            }

            setupEventListeners() {
                const boardContainer = document.querySelector('.grid');
                
                // Prevent right-click context menu
                boardContainer.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                boardContainer.addEventListener('click', (e) => {
                    const square = e.target.closest('.chess-square');
                    if (!square) return;

                    const squareName = square.dataset.square;
                    const piece = this.chess.get(squareName);

                    // Only allow moves on player's turn
                    if (!this.isPlayerTurn()) return;

                    // Clear previous selections
                    document.querySelectorAll('.chess-square').forEach(sq => {
                        sq.classList.remove('selected', 'valid-move');
                    });

                    if (this.selectedPiece) {
                        const fromSquare = this.selectedPiece;
                        
                        // Check if it's a valid move
                        const validMoves = this.getValidMoves(fromSquare);
                        const isValidMove = validMoves.some(move => move.to === squareName);
                        
                        if (isValidMove) {
                            // Check for pawn promotion
                            if (this.handlePawnPromotion(fromSquare, squareName)) {
                                // Promotion modal will handle the move
                                return;
                            }
                            
                            this.makeMove(fromSquare, squareName);
                            this.selectedPiece = null;
                        } else if (piece && piece.color === this.chess.turn()) {
                            this.selectedPiece = squareName;
                            square.classList.add('selected');
                            this.showValidMoves(squareName);
                        } else {
                            this.selectedPiece = null;
                        }
                    } else if (piece && piece.color === this.chess.turn()) {
                        this.selectedPiece = squareName;
                        square.classList.add('selected');
                        this.showValidMoves(squareName);
                    }
                });

                this.surrenderBtn.addEventListener('click', () => {
                    this.surrenderGame();
                });

                this.restartBtn.addEventListener('click', () => {
                    this.restartGame();
                });

                this.drawBtn.addEventListener('click', () => {
                    this.offerDraw();
                });

                this.gameModeSelect.addEventListener('change', (e) => {
                    this.gameMode = e.target.value;
                    this._determinedColor = null; // Reset determined color
                    this.botControls.classList.toggle('hidden', this.gameMode !== 'bot');
                    this.botInfo.classList.toggle('hidden', this.gameMode !== 'bot');
                    this.drawBtn.classList.toggle('hidden', this.gameMode !== 'bot');
                    this.drawBtn.disabled = this.gameMode !== 'bot' || this.chess.game_over() || this.chess.history().length === 0;
                    
                    // Reset the game when game mode changes
                    this.chess = new Chess();
                    this.selectedPiece = null;
                    this.renderBoard();
                    this.updateGameStatus();
                    this.saveGameState();
                });

                this.botDifficultySelect.addEventListener('change', (e) => {
                    this.botDifficulty = parseInt(e.target.value);
                    this.saveGameState();
                });

                this.playerColorSelect.addEventListener('change', (e) => {
                    this.playerColor = e.target.value;
                    this._determinedColor = null; // Reset determined color
                    this.saveGameState();
                    // Reset the game when color changes
                    this.chess = new Chess();
                    this.selectedPiece = null;
                    this.renderBoard();
                    this.updateGameStatus();
                    this.syncUIWithGameState();
                });

                // Promotion modal event listeners
                this.promotionModal.addEventListener('click', (e) => {
                    const promotionButton = e.target.closest('.promotion-piece');
                    if (promotionButton) {
                        const promotionPiece = promotionButton.dataset.piece;
                        // console.log('Promotion piece selected:', promotionPiece);
                        if (this.pendingPromotion) {
                            this.makeMove(this.pendingPromotion.from, this.pendingPromotion.to, promotionPiece);
                            this.hidePromotionModal();
                            this.selectedPiece = null;
                        }
                    } else if (e.target === this.promotionModal) {
                        // Click outside modal to cancel
                        this.hidePromotionModal();
                        this.selectedPiece = null;
                    }
                });

                // PGN modal event listeners
                this.copyPgnBtn.addEventListener('click', () => {
                    const pgn = this.getGamePGN();
                    navigator.clipboard.writeText(pgn).then(() => {
                        this.copyPgnBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            this.copyPgnBtn.textContent = 'Copy PGN';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy PGN:', err);
                    });
                });

                this.closePgnBtn.addEventListener('click', () => {
                    this.hidePGNModal();
                });

                // Close PGN modal when clicking outside
                this.pgnModal.addEventListener('click', (e) => {
                    if (e.target === this.pgnModal) {
                        this.hidePGNModal();
                    }
                });
            }

            showValidMoves(square) {
                const validMoves = this.getValidMoves(square);
                validMoves.forEach(move => {
                    const squareElement = document.querySelector(`[data-square="${move.to}"]`);
                    if (squareElement) {
                        squareElement.classList.add('valid-move');
                    }
                });
            }

            resetGame() {
                this.chess = new Chess();
                this.selectedPiece = null;
                this._determinedColor = null; // Reset determined color
                this.renderBoard();
                this.updateGameStatus();
                
                // Clear localStorage for a fresh start
                localStorage.removeItem('chessGameState');
                
                // Initialize fresh game
                this.initializeGame();
            }

            offerDraw() {
                // Only allow draw offers when it's the human's turn and playing against bot
                if (this.gameMode === 'bot' && this.isPlayerTurn() && !this.chess.game_over()) {
                    // Simple bot logic: accept draw with 50% probability
                    const botAccepts = Math.random() < 0.5;
                    
                    if (botAccepts) {
                        // Bot accepts the draw - add draw result to the game
                        this.chess.header('Result', '1/2-1/2');
                        this.gameStatus.textContent = 'Draw by agreement!';
                        this.gameStatus.className = 'text-yellow-400 font-medium';
                        this.syncUIWithGameState(); // Update draw button state
                        
                        // Show PGN modal only if there are moves in the game
                        if (this.chess.history().length > 0) {
                            setTimeout(() => {
                                this.showPGNModal();
                            }, 1000);
                        }
                    } else {
                        // Bot declines the draw
                        this.gameStatus.textContent = 'Bot declined the draw offer';
                        this.gameStatus.className = 'text-orange-400 font-medium';
                        
                        // Reset status after 3 seconds
                        setTimeout(() => {
                            this.updateGameStatus();
                        }, 3000);
                    }
                }
            }

            playMoveSound() {
                // console.log('Attempting to play move sound...');
                try {
                    // Create audio context
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // console.log('Audio context created:', audioContext);
                    
                    // Create oscillator for beep sound
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    // console.log('Audio nodes created');
                    
                    // Connect nodes
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    // console.log('Audio nodes connected');
                    
                    // Configure sound
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800Hz beep
                    oscillator.type = 'sine';
                    
                    // Configure volume
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // Low volume
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    // Play sound
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1); // 100ms duration
                    // console.log('Move sound played successfully');
                    
                } catch (error) {
                    // console.error('Audio play failed:', error);
                }
            }

            getGamePGN() {
                return this.chess.pgn();
            }

            showPGNModal() {
                console.log('showPGNModal called');
                const pgn = this.getGamePGN();
                console.log('PGN:', pgn);
                this.pgnText.textContent = pgn;
                this.pgnModal.classList.remove('hidden');
                console.log('PGN modal should be visible now');
            }

            hidePGNModal() {
                this.pgnModal.classList.add('hidden');
            }

            surrenderGame() {
                if (this.chess.game_over() || this.chess.history().length === 0) return;
                
                // Determine winner based on current turn
                const winner = this.chess.turn() === 'w' ? 'Black' : 'White';
                this.gameStatus.textContent = `${winner} wins by resignation!`;
                this.gameStatus.className = 'text-red-400 font-medium';
                
                // Add resignation result to the game
                this.chess.header('Result', winner === 'White' ? '1-0' : '0-1');
                
                this.syncUIWithGameState();
                
                // Show PGN modal after a short delay
                setTimeout(() => {
                    this.showPGNModal();
                }, 1000);
            }

            restartGame() {
                this.chess = new Chess();
                this.selectedPiece = null;
                this._determinedColor = null; // Reset determined color
                this.renderBoard();
                this.updateGameStatus();
                
                // Clear localStorage for a fresh start
                localStorage.removeItem('chessGameState');
                
                // Initialize fresh game
                this.initializeGame();
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Add a small delay to ensure all elements are properly loaded
            setTimeout(() => {
                new ChessGame();
            }, 100);
        });
    </script>
</body>
</html> 